#pragma config(Sensor, S1,     light1,         sensorLightActive)
#pragma config(Sensor, S2,     light2,         sensorColorNxtRED)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          leopold,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Links 34, 67, S2
// Rechts 35, 66, S1

#pragma platform(NXT);

#include "remote_control.c";

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

// Controleert of er een object voor het apparaat staat.
void scan_for_object(int sensor_value)
{
	if(sensor_value <= 15){
		stop_motor();
		shoot();
	}
}

// Ask for user input.
int ask_direction()
{
	TFileIOResult nBTCmdRdErrorStatus;
	int nSizeOfMessage;
	ubyte nRcvBuffer[kMaxSizeOfMessage];

	nSizeOfMessage = cCmdMessageGetSize(INBOX);

	if (nSizeOfMessage > kMaxSizeOfMessage) {
		nSizeOfMessage = kMaxSizeOfMessage;
	}

	if (nSizeOfMessage > 0){
		nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
		nRcvBuffer[nSizeOfMessage] = '\0';
		string input = "";
		stringFromChars(input, (char *) nRcvBuffer);
		displayCenteredBigTextLine(5, input);

		if(input == "LEFT"){
			turn_left();
			return 1;
		} else if(input == "RIGHT"){
			turn_right();
			return 1;
		} else if(input == "UP"){
			move_forward();
			return 1;
		}
	}

	return 0;
}


// Handmatige besturing via bluetooth.
task remote_control()
{
	TFileIOResult nBTCmdRdErrorStatus;
	int nSizeOfMessage;
	ubyte nRcvBuffer[kMaxSizeOfMessage];

	while(1){
		nSizeOfMessage = cCmdMessageGetSize(INBOX);

		if (nSizeOfMessage > kMaxSizeOfMessage) {
			nSizeOfMessage = kMaxSizeOfMessage;
		}

		if (nSizeOfMessage > 0){
			nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
			nRcvBuffer[nSizeOfMessage] = '\0';
			string input = "";
			stringFromChars(input, (char *) nRcvBuffer);
			displayCenteredBigTextLine(5, input);

			if(input == "LEFT"){
				turn_left();
			} else if(input == "RIGHT"){
				turn_right();
			} else if(input == "DOWN"){
				turn_backwards();
			} else if(input == "UP"){
				move_forward();
			} else if(input == "B"){
				stop_motor();
			} else if(input == "FIRE"){
				stop_motor();
				shoot();
			}
		}
	}
}


// Volgt de zwarte lijn automatisch.
task follow_line()
{
	int light_right,
			light_left,
			ultrasonic;

	while(1){
		light_right = SensorValue[S1];
		light_left = SensorValue[S2];
		ultrasonic = SensorValue[S4];

		motor[motorB] = (3*(light_right-light_left*0.5-18));
		motor[motorC] = (3*(light_left-light_right*0.5-18));

		// Kruispunt
		if((light_right < 40) && (light_left < 40)){
			stop_motor();

			// Loop tot input.
			while(1){
				if(ask_direction() == 1) {
					// Loop tot de lichtwaarden hoger zijn dan 60 (wit).
					while((SensorValue[S1] < 60) && (SensorValue[S2] < 60)){
						wait1Msec(10);
					}
					break;
				}
			}
		}

		scan_for_object(ultrasonic);
		wait1Msec(1);
	}
}


// Toggle tussen automatisch en handmatig.
void switch_mode()
{
	TFileIOResult nBTCmdRdErrorStatus;
	int nSizeOfMessage;
	ubyte nRcvBuffer[kMaxSizeOfMessage];

	while(1){
		nSizeOfMessage = cCmdMessageGetSize(INBOX);

		if (nSizeOfMessage > kMaxSizeOfMessage) {
			nSizeOfMessage = kMaxSizeOfMessage;
		}

		if (nSizeOfMessage > 0){
			nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
			nRcvBuffer[nSizeOfMessage] = '\0';
			string input = "";
			stringFromChars(input, (char *) nRcvBuffer);

			if(input == "A"){
				stopTask(follow_line);
				stop_motor();
				startTask(remote_control);
				displayCenteredTextLine(4, "start remote");
			} else if(input == "C"){
				stopTask(remote_control);
				stop_motor();
				startTask(follow_line);
				displayCenteredTextLine(4, "start automatic");
			}
		}
	}
}


task main()
{
	while(1){
		switch_mode();
		wait1Msec(1);
	}
}
